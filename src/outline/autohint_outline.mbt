// Copyright 2025 International Digital Economy Academy
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

///|
/// Minimal outline extraction for the autohinter.
///
/// This mirrors upstream's `outline/autohint/outline.rs` "unscaled sink" stage,
/// but uses `PathElement` streams (generated by `OutlineGlyph::path`) as the
/// source representation.

///|
priv struct AutoHintPoint {
  x : Int
  y : Int
  on_curve : Bool
}

///|
priv struct AutoHintOutline {
  points : Array[AutoHintPoint]
  contours : Array[Int]
}

///|
fn autohint_round_font_units(v : Double) -> Int {
  v.round().to_int()
}

///|
fn AutoHintOutline::from_path(path : Array[PathElement]) -> AutoHintOutline {
  let points : Array[AutoHintPoint] = Array::new()
  let contours : Array[Int] = Array::new()
  let mut in_contour = false
  for e in path.iter() {
    match e {
      PathElement::MoveTo(x, y) => {
        if in_contour && points.length() > 0 {
          contours.push(points.length() - 1)
        }
        points.push(AutoHintPoint::{
          x: autohint_round_font_units(x),
          y: autohint_round_font_units(y),
          on_curve: true,
        })
        in_contour = true
      }
      PathElement::LineTo(x, y) =>
        if in_contour {
          points.push(AutoHintPoint::{
            x: autohint_round_font_units(x),
            y: autohint_round_font_units(y),
            on_curve: true,
          })
        }
      PathElement::QuadTo(cx0, cy0, x, y) =>
        if in_contour {
          points.push(AutoHintPoint::{
            x: autohint_round_font_units(cx0),
            y: autohint_round_font_units(cy0),
            on_curve: false,
          })
          points.push(AutoHintPoint::{
            x: autohint_round_font_units(x),
            y: autohint_round_font_units(y),
            on_curve: true,
          })
        }
      PathElement::CurveTo(cx0, cy0, cx1, cy1, x, y) =>
        if in_contour {
          points.push(AutoHintPoint::{
            x: autohint_round_font_units(cx0),
            y: autohint_round_font_units(cy0),
            on_curve: false,
          })
          points.push(AutoHintPoint::{
            x: autohint_round_font_units(cx1),
            y: autohint_round_font_units(cy1),
            on_curve: false,
          })
          points.push(AutoHintPoint::{
            x: autohint_round_font_units(x),
            y: autohint_round_font_units(y),
            on_curve: true,
          })
        }
      PathElement::Close =>
        if in_contour {
          if points.length() > 0 {
            contours.push(points.length() - 1)
          }
          in_contour = false
        }
    }
  }
  if in_contour && points.length() > 0 {
    contours.push(points.length() - 1)
  }
  AutoHintOutline::{ points, contours }
}

///|
fn AutoHintOutline::is_empty(self : AutoHintOutline) -> Bool {
  self.contours.length() == 0
}

///|
/// Returns basic stats for the extracted outline.
///
/// This is used by the autohinter pipeline (bounds-based heuristics). Keeping
/// it here also avoids unused-field warnings while the full hinting passes are
/// being ported.
fn AutoHintOutline::stats(self : AutoHintOutline) -> (Int, Int, Int, Int, Int) {
  if self.points.length() == 0 {
    return (0, 0, 0, 0, 0)
  }
  let mut min_x = self.points.at(0).x
  let mut min_y = self.points.at(0).y
  let mut max_x = min_x
  let mut max_y = min_y
  let mut on_curve = 0
  for p in self.points.iter() {
    if p.x < min_x {
      min_x = p.x
    }
    if p.y < min_y {
      min_y = p.y
    }
    if p.x > max_x {
      max_x = p.x
    }
    if p.y > max_y {
      max_y = p.y
    }
    if p.on_curve {
      on_curve = on_curve + 1
    }
  }
  (min_x, min_y, max_x, max_y, on_curve)
}
